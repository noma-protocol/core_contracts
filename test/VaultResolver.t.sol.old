// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import "forge-std/Test.sol";
import {BaseVault} from  "../src/vault/BaseVault.sol";
import {IUniswapV3Pool} from "@uniswap/v3-core/interfaces/IUniswapV3Pool.sol";
import {IAddressResolver} from "../src/interfaces/IAddressResolver.sol";
import {Utils} from "../src/libraries/Utils.sol";
import {Conversions} from "../src/libraries/Conversions.sol";
import {Underlying } from  "../src/libraries/Underlying.sol";
import {DecimalMath} from "../src/libraries/DecimalMath.sol";
import {LiquidityType, LiquidityPosition} from "../src/types/Types.sol";
import {MockNomaToken} from  "../src/token/MockNomaToken.sol";
import {ModelHelper} from  "../src/model/Helper.sol";
import {IVault} from "../src/interfaces/IVault.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IDOHelper} from "./IDO_Helper/IDOHelper.sol";

interface IDOManager {
    function vault() external view returns (BaseVault);
    function buyTokens(uint256 price, uint256 amount, address receiver) external;
    function sellTokens(uint256 price, uint256 amount, address receiver) external;
    function modelHelper() external view returns (address);
}

interface IWETH {
    function balanceOf(address account) external view returns (uint256);
    function deposit() external payable;
    function transfer(address to, uint value) external returns (bool);
}

contract VaultResolverTest is Test {
    // Get environment variables.
    address feeTo = vm.envAddress("FEE_TO");
    uint256 privateKey = vm.envUint("PRIVATE_KEY");
    address deployer = vm.envAddress("DEPLOYER");
    bytes32 salt = keccak256(bytes(vm.envString("SALT")));

    address payable idoManager = payable(0x7D6Cb1678d761C100566eC1D25ceC421e4F3A0a7);
    address nomaToken = 0x2cC63B1106F6291c36DFCeE6BACd8529E5B4cA6f;
    address modelHelperContract = 0x6D47E56d5CD83d396AC92F1f66e7D095925B4D0C;   
    address WETH = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;
    address vaultAddress = 0x1b26D84372D1F8699a3a71801B4CA757B95C9929;
    address resolverAddress = 0x683EFA1f67f3029152238F2E99600CD96e2561F4;

    MockNomaToken private noma;
    ModelHelper private modelHelper;
    IVault vault;
    IERC20 token0;
    IERC20 token1;

    function setUp() public {

        noma = MockNomaToken(nomaToken);
        require(address(noma) != address(0), "Noma token address is zero");
        
        modelHelper = ModelHelper(modelHelperContract);
        
        console.log("Vault address is: ", vaultAddress);

        // Initialize the existing vault contract
        vault = IVault(vaultAddress);

        IUniswapV3Pool pool = vault.pool();

        token0 = IERC20(pool.token0());  
        token1 = IERC20(pool.token1());    

                
        testLargePurchaseTriggerShift();
    }

    function testImportNullAddress() public {
        IAddressResolver resolver = IAddressResolver(resolverAddress);

        bytes32 name = Utils.stringToBytes32("AdaptiveSupply");
        bytes32[] memory names = new bytes32[](1);
        names[0] = name;

        address _adaptiveSupply = address(0);
        address[] memory destinations  = new address[](1);
        destinations[0] = _adaptiveSupply;
        
        vm.prank(deployer);
        resolver.importVaultAddress(vaultAddress, names, destinations);

        vm.prank(deployer);
        resolver.importAddresses(names, destinations);

        testLargePurchaseTriggerShift();
    }

    function testLargePurchaseTriggerShift() public {
        IDOHelper managerContract = IDOHelper(idoManager);
        BaseVault vault = managerContract.vault();
        address pool = address(vault.pool());

        (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(pool).slot0();
        uint256 spotPrice = Conversions.sqrtPriceX96ToPrice(sqrtPriceX96, 18);
        uint256 purchasePrice = spotPrice + (spotPrice * 1 / 100);

        uint16 totalTrades = 500;
        uint256 tradeAmount = 100 ether;

        IWETH(WETH).deposit{ value: (tradeAmount * totalTrades)}();
        IWETH(WETH).transfer(idoManager, tradeAmount * totalTrades);

        require(address(noma) != address(0), "Noma token address is zero");

        uint256 tokenBalanceBefore = noma.balanceOf(address(this));
        uint256 circulatingSupplyBefore = modelHelper.getCirculatingSupply(pool, address(vault));
        console.log("Circulating supply is: ", circulatingSupplyBefore);

        for (uint i = 0; i < totalTrades; i++) {
            (sqrtPriceX96,,,,,,) = IUniswapV3Pool(pool).slot0();
            spotPrice = Conversions.sqrtPriceX96ToPrice(sqrtPriceX96, 18);
            purchasePrice = spotPrice + (spotPrice * i / 100);
            if (i >= 4) {
                spotPrice =  purchasePrice;
            }
            managerContract.buyTokens(spotPrice, tradeAmount, deployer);
        }
        
        uint256 nextFloorPrice = getNextFloorPrice(pool, address(vault));
        console.log("Next floor price is: ", nextFloorPrice);

        uint256 liquidityRatio = modelHelper.getLiquidityRatio(pool, address(vault));
        console.log("Liquidity ratio is: ", liquidityRatio);

        if (liquidityRatio < 0.90e18) {
            console.log("Attempt to shift positions");
            IVault(address(vault)).shift();
            nextFloorPrice = getNextFloorPrice(pool, address(vault));
            console.log("Next floor price (after shift) is: ", nextFloorPrice);

        } else {
            revert(
                string(
                    abi.encodePacked(
                        "no shift triggered: ", 
                        Utils._uint2str(liquidityRatio)
                    )
                )
            );
        }
    }

    function getNextFloorPrice(address pool, address vault) public view returns (uint256) {
        LiquidityPosition[3] memory positions = IVault(vault).getPositions();
        uint256 circulatingSupply = modelHelper.getCirculatingSupply(pool, vault);
        uint256 anchorCapacity = modelHelper.getPositionCapacity(pool, vault, positions[1], LiquidityType.Anchor);
        (,,,uint256 floorBalance) = Underlying.getUnderlyingBalances(pool, vault, positions[0]);

        return DecimalMath.divideDecimal(floorBalance, circulatingSupply > anchorCapacity ? circulatingSupply - anchorCapacity : circulatingSupply);
    }    
}